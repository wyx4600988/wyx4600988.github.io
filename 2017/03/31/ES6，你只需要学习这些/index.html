<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="yes" name="apple-touch-fullscreen"><meta content="telephone=no,email=no" name="format-detection"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet"><script src="https://use.fontawesome.com/adaf0e149c.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/monokai_sublime.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/markdown-github.css"><title>林水溶的博客</title><script src="/js/googleAnalytics.js"></script></head><body><div id="postContainer"><div id="postTop"><h4 id="logo">Life Is Short</h4><br><br><h2 id="postTitle">ES6，你只需要学习这些</h2><br><span aria-hidden="true" class="postTime fa fa-calendar">2017-3-31</span><span aria-hidden="true" class="postTags fa fa-tags">&nbsp;前端</span><span aria-hidden="true" class="postTags fa fa-tags">&nbsp;ES6</span><br><br></div><section id="articleDiv"><p>2017年前端程序员技能标配，应该有ES6一席之位．</p><br><p>而学习ES6，就不得不提到阮一峰的<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">ECMAScript 6 入门</a>, 但这本书讲的东西太多了，讲的比较细，牵涉的面也比较广．但有的人<strong>就想学ES6,暂时不想知道其他东西</strong>，但不全看下来，根本不知道哪里是ES6的东西，哪里不是．．．</p><br><p><strong>所以，这就是本篇的意义所在</strong></p><br><p>(注: 本文所有内容皆来自阮一峰的ES6入门．我只不过给精简了,顺便从头学习一波)</p><br><hr><br><pre><code class="javascript">/<em> 本篇包括： </em>/<br>let和const, 变量的解构赋值, 字符串的扩展, 正则的扩展, 数值的扩展, 数组的扩展, 函数的扩展, 对象的扩展<br></code></pre><br><h4 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h4><hr><br><p><strong>let</strong></p><br><ul><br><li>let，声明块变量，即变量只在其所在的代码快内有效．</li><br></ul><br><pre><code class="javascript">{<br>  let a = 10;<br>  var b = 1;<br>}<br><br>a /<em> ReferenceError: a is not defined. </em>/<br>b /<em> 1 </em>/<br></code></pre><br><ul><br><li>var，声明变量会发生”变量提升”现象，而let 声明的变量则不会．</li><br></ul><br><pre><code class="javascript">/<em> var 的情况 </em>/<br>console.log(foo); /<em> 输出undefined </em>/<br>var foo = 2;<br><br>/<em> let 的情况 </em>/<br>console.log(bar); /<em> 报错ReferenceError </em>/<br>let bar = 2;<br></code></pre><br><ul><br><li>暂时性死区：在代码块内，使用<code>let</code>命令声明变量之前，该变量是不可用的．</li><br></ul><br><pre><code class="javascript">var tmp = 123;<br><br>if (true) {<br>  tmp = &#39;abc&#39;; /<em> ReferenceError.尽管tmp上面已经声明．但这个块内有let tmp的话，就会形成暂时性死区．造成访问错误．</em>/<br>  let tmp;<br>}<br></code></pre><br><ul><br><li>不允许在同一个块作用域中，重复声明同一个变量</li><br></ul><br><pre><code class="javascript">/<em> 报错 </em>/<br>function () {<br>  let a = 10;<br>  var a = 1;<br>}<br><br>/<em> 报错 </em>/<br>function () {<br>  let a = 10;<br>  let a = 1;<br>}<br></code></pre><br><p><strong>const</strong></p><br><ul><br><li>声明一个只读的常量。一旦声明，常量的值就不能改变。</li><br><li>本质上，保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。也就是说，<strong>数组和对象的内容是可以变的．</strong></li><br></ul><br><h4 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h4><hr><br><p><strong>解构</strong> : 按照一定模式，从数组和对象中提取值，对变量进行赋值．</p><br><p>１．数组</p><br><pre><code class="javascript">/<em>以前是这样</em>/<br>let a = 1;<br>let b = 2;<br>let c = 3;<br>/<em>现在是这样</em>/<br>let [a, b, c] = [1, 2, 3];<br><br>/<em>更多例子</em>/<br>let [x, y] = [1, 2, 3];<br>x /<em> 1 </em>/<br>y /<em> 2 </em>/<br><br>let [foo, [[bar], baz]] = [1, [[2], 3]];<br>foo /<em> 1 </em>/<br>bar /<em> 2 </em>/<br>baz /<em> 3 </em>/<br><br>let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];<br>third /<em> &quot;baz&quot; </em>/<br><br>let [x, , y] = [1, 2, 3];<br>x /<em> 1 </em>/<br>y /<em> 3 </em>/<br><br>let [head, …tail] = [1, 2, 3, 4];<br>head /<em> 1 </em>/<br>tail /<em> [2, 3, 4] </em>/<br><br>let [x, y, …z] = [&#39;a&#39;];<br>x /<em> &quot;a&quot; </em>/<br>y /<em> undefined </em>/<br>z /<em> [] </em>/<br></code></pre><br><ul><br><li>如果解构不成功，变量的值就等于undefined</li><br><li>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值</li><br></ul><br><p><strong>允许默认值</strong></p><br><pre><code class="javascript">let [foo = true] = [];<br>foo /<em> true </em>/<br>let [x, y = &#39;b&#39;] = [&#39;a&#39;]; /<em> x=&#39;a&#39;, y=&#39;b&#39; </em>/<br>let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; /<em> x=&#39;a&#39;, y=&#39;b&#39; </em>/<br></code></pre><br><ul><br><li>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</li><br><li>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</li><br></ul><br><pre><code class="javascript">function f() {<br>  console.log(&#39;aaa&#39;);<br>}<br>let [x = f()] = [1]; /<em> x = 1 </em>/<br></code></pre><br><ul><br><li>默认值可以引用其他变量，但该变量必须已经声明。</li><br></ul><br><p>２．对象</p><br><ul><br><li>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</li><br></ul><br><pre><code class="javascript">let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };<br>foo /<em> &quot;aaa&quot; </em>/<br>bar /<em> &quot;bbb&quot; </em>/<br><br>let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };<br>baz /<em> undefined </em>/<br></code></pre><br><ul><br><li>如果变量名与属性名不一致，必须写成下面这样。</li><br></ul><br><pre><code class="javascript">let { first: f, last: l } = { first: &#39;hello&#39;, last: &#39;world&#39; };<br>f /<em> &#39;hello&#39; </em>/<br>l /<em> &#39;world&#39; </em>/<br></code></pre><br><p>上面代码中. first,last 是匹配的模式，f,l 才是变量。真正被赋值的是变量f,l ，而不是模式 first, last。</p><br><p>看这个</p><br><pre><code class="javascript">let baz;<br>let {bar: baz} = {bar: 1}; /<em> SyntaxError: 重复声明 &quot;baz&quot; </em>/<br>let baz;<br>({bar: baz} = {bar: 1}); /<em> 成功　</em>/<br></code></pre><br><ul><br><li>圆括号是必须的，为了不让解析器将开头的大括号理解为代码块，而是赋值语句．</li><br><li>解构嵌套的对象</li><br></ul><br><pre><code class="javascript">var node = {<br>  loc: {<br>    start: {<br>      line: 1,<br>      column: 5<br>    }<br>  }<br>};<br>var { loc: { start: { line }} } = node;<br>line /<em> 1 </em>/<br>loc  /<em> error: loc is undefined </em>/<br>start /<em> error: start is undefined </em>/<br></code></pre><br><ul><br><li>对象的解构同样可以指定默认值</li><br></ul><br><pre><code class="javascript">var {x, y = 5} = {x: 1};<br>x /<em> 1 </em>/<br>y /<em> 5 </em>/<br>var {x:y = 3} = {x: 5};<br>y /<em> 5 </em>/<br></code></pre><br><ul><br><li>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</li><br></ul><br><pre><code class="javascript">let arr = [1, 2, 3];<br>let {0 : first, [arr.length - 1] : last} = arr;<br>first /<em> 1 </em>/<br>last /<em> 3 </em>/<br></code></pre><br><p>３．字符串的解构赋值</p><br><pre><code class="javascript">const [a, b, c, d, e] = &#39;hello&#39;;<br>a /<em> &quot;h&quot; </em>/<br>b /<em> &quot;e&quot; </em>/<br>c /<em> &quot;l&quot; </em>/<br>d /<em> &quot;l&quot; </em>/<br>e /<em> &quot;o&quot; </em>/<br>let {length : len} = &#39;hello&#39;;   /<em> 字符串有length属性 </em>/<br>len /<em> 5 </em>/<br></code></pre><br><p>４．函数参数的解构赋值</p><br><pre><code class="javascript">function move({x = 0, y = 0} = {}) {<br>  return [x, y];<br>}<br>move({x: 3, y: 8}); /<em> [3, 8] </em>/<br>move({x: 3}); /<em> [3, 0] </em>/<br>move({}); /<em> [0, 0] </em>/<br>move(); /<em> [0, 0] </em>/<br></code></pre><br><p>５．解构赋值的常见用途</p><br><pre><code class="javascript">/<em> １．交换变量 </em>/<br>let x = 1;<br>let y = 2;<br>[x, y] = [y, x];<br><br>/<em> ２．匹配函数返回值 </em>/<br>function example() {<br>  return [1, 2, 3];<br>}<br>let [a, b, c] = example();<br><br>function example() {<br>  return {<br>    foo: 1,<br>    bar: 2<br>  };<br>}<br>let { foo, bar } = example();<br><br>/<em> 3.无序的传递函数参数 </em>/<br>function f({x, y, z}) { … }<br>f({z: 3, y: 2, x: 1});<br><br>/<em> 4.提取JSON数据 </em>/<br>let jsonData = {<br>  id: 42,<br>  status: &quot;OK&quot;,<br>  data: [867, 5309]<br>};<br>let { id, status, data: number } = jsonData;<br><br>/<em> 5.函数参数的默认值 </em>/<br>jQuery.ajax = function (url, {<br>  async = true,<br>  beforeSend = function () {},<br>  cache = true,<br>  complete = function () {},<br>  crossDomain = false,<br>  global = true,<br>  /<em> … more config </em>/<br>}) {<br>  /<em> … do stuff </em>/<br>};<br></code></pre><br><h4 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h4><hr><br><ul><br><li>ES6为字符串添加了遍历器接口，使得字符串可以被<code>for…of</code>循环遍历。</li><br></ul><br><pre><code class="javascript">for (let codePoint of &#39;foo&#39;) {<br>  console.log(codePoint)<br>}<br>/<em> &quot;f&quot; </em>/<br>/<em> &quot;o&quot; </em>/<br>/<em> &quot;o&quot; </em>/<br></code></pre><br><ul><br><li>includes(), startsWith(), endsWith()</li><br></ul><br><pre><code class="javascript">includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。<br></code></pre><br><pre><code class="javascript">var s = &#39;Hello world!&#39;;<br>s.startsWith(&#39;Hello&#39;) /<em> true </em>/<br>s.endsWith(&#39;!&#39;) /<em> true </em>/<br>s.includes(&#39;o&#39;) /<em> true </em>/<br>/<em> 这三个方法都支持第二个参数，表示开始搜索的位置。 </em>/<br>s.startsWith(&#39;world&#39;, 6) /<em> true </em>/<br>s.endsWith(&#39;Hello&#39;, 5) /<em> true  endsWith的行为与其他两个方法有所不同。它针对前n个字符,否则就没有意义了，你想想是不是？ </em>/<br>s.includes(&#39;Hello&#39;, 6) /<em> false </em>/<br></code></pre><br><ul><br><li>repeat(): 返回一个新字符串，表示将原字符串重复<code>n</code>次</li><br></ul><br><pre><code class="javascript">&#39;hello&#39;.repeat(2) /<em> &quot;hellohello&quot; </em>/<br>&#39;na&#39;.repeat(0) /<em> &quot;&quot; </em>/<br>&#39;na&#39;.repeat(2.9) /<em> &quot;nana&quot; 参数如果是小数，会被取整 </em>/<br>/<em> 参数是负数或者Infinity. 参数是0到-1之间的小数,会先进行取整为-0 等同于０, NaN 也等同于０</em>/<br>&#39;na&#39;.repeat(-0.9) /<em> &quot;&quot; </em>/<br>/<em> 参数是字符串的话，会先转换成数字　</em>/<br>&#39;na&#39;.repeat(&#39;na&#39;) /<em> &quot;&quot;  &#39;na&#39;转换成了NaN</em>/<br>&#39;na&#39;.repeat(&#39;3&#39;) /<em> &quot;nanana&quot;  &#39;3&#39;转换成了３</em>/<br></code></pre><br><ul><br><li>模板字符串 ( 重点 )</li><br></ul><br><pre><code class="javascript">/<em> 以前是这样写的 </em>/<br>$(&#39;#result&#39;).append(<br>  &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;/b&gt; &#39; +<br>  &#39;items in your basket, &#39; +<br>  &#39;&lt;em&gt;&#39; + basket.onSale +<br>  &#39;&lt;/em&gt; are on sale!&#39;<br>);<br><br>/<em> 现在是这样．前后两个反引号．注意，空格和缩进会被保存　</em>/<br>/<em> 用${}的方法可以嵌入变量 </em>/<br>$(&#39;#result&#39;).append(<code>There are &amp;lt;b&amp;gt;${basket.count}&amp;lt;/b&amp;gt; items
   in your basket, &amp;lt;em&amp;gt;${basket.onSale}&amp;lt;/em&amp;gt;
  are on sale!</code>);<br><br>/<em> ${}内可以执行JS表达式　</em>/<br>var x = 1;<br>var y = 2;<br><code>${x} + ${y * 2} = ${x + y * 2}</code><br>/<em> &quot;1 + 4 = 5&quot; </em>/<br><br>var obj = {x: 1, y: 2};<br><code>${obj.x + obj.y}</code><br>/<em> 3 </em>/<br><br>/<em> 能调用函数 </em>/<br>function fn() {<br>  return &quot;Hello World&quot;;<br>}<br><code>foo ${fn()} bar</code><br>/<em> foo Hello World bar </em>/<br></code></pre><br><ul><br><li>标签模板：其实是函数调用的另一种方式</li><br></ul><br><pre><code class="javascript">alert<code>123</code><br>/<em> 等同于 </em>/<br>alert(123)<br></code></pre><br><h4 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h4><hr><br><ul><br><li>字符串的四个正则方法：　match(), replace(), search(), split(),　JS内部全部调用RegExp的实例方法．从而做到所有与正则相关的方法，全都定义在RegExp对象上．</li><br></ul><br><pre><code class="javascript">String.prototype.match 调用 RegExp.prototype[Symbol.match]<br>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]<br>String.prototype.search 调用 RegExp.prototype[Symbol.search]<br>String.prototype.split 调用 RegExp.prototype[Symbol.split]<br></code></pre><br><ul><br><li>u 修饰符: 含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码</li><br><li>y 修饰符: 和g类似，也是全局匹配，<code>g</code>只要剩余位置中存在匹配就可，而<code>y</code>确保匹配必须从剩余的第一个位置开始．也就是说：y相当于隐含了个^(头部匹配).</li><br><li>ES6的正则对象多了个sticky属性，表示是否设置了<code>y</code>修饰符</li><br><li>新增了<code>flags</code>属性，会返回正则表达式的修饰符。</li><br></ul><br><pre><code class="javascript">/abc/ig.flags<br>/<em> &#39;gi&#39; </em>/<br></code></pre><br><h4 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h4><hr><br><ul><br><li>ES6将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到Number对象上面，行为完全保持不变。目的是为了逐步减少全局性方法，使得语言逐步模块化。</li><br><li><code>Number.isInteger()</code>用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值</li><br><li>指数运算符　(<strong> )</li><br></ul><br><pre><code class="javascript">let a = 1.5;<br>a </strong>= 2;  /<em> 2.25 </em>/<br>/<em> 等同于 a = a </em> a; <em>/<br><br>/</em> 注意和　a <em>= 2 的差别　</em>/<br>a = 1.5;<br>a <em>= 2; /</em> 3 <em>/<br></code></pre><br><h4 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h4><hr><br><ul><br><li>Array.from() 用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）．</li><br></ul><br><p>所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组．</p><br><pre><code class="javascript">let arrayLike = {<br>    &#39;0&#39;: &#39;a&#39;,<br>    &#39;1&#39;: &#39;b&#39;,<br>    &#39;2&#39;: &#39;c&#39;,<br>    length: 3<br>};<br>/</em> ES5的写法 <em>/<br>var arr1 = [].slice.call(arrayLike); /</em> [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] <em>/<br>/</em> ES6的写法 <em>/<br>let arr2 = Array.from(arrayLike); /</em> [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] <em>/<br></code></pre><br><p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组，然后就可以用众多的数组方法了．</p><br><p>如果参数是一个真正的数组，<code>Array.from</code>会返回一个一模一样的新数组。</p><br><p>值得提醒的是，<strong>扩展运算符（<code>…</code>）</strong>也可以将某些数据结构转为数组。本质上调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换．</p><br><p>Array.from<code>还可以接受第二个参数，作用类似于数组的</code>map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><br><ul><br><li><code>Array.of</code>方法用于将一组值，转换为数组</li><br></ul><br><pre><code class="javascript">Array.of(3, 11, 8) /</em> [3,11,8] <em>/<br>Array.of(3) /</em> [3] <em>/<br>Array.of(3).length /</em> 1 <em>/<br></code></pre><br><p>方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足</p><br><pre><code class="javascript">Array() /</em> [] <em>/<br>Array(3) /</em> [, , ,] <em>/<br>Array(3, 11, 8) /</em> [3, 11, 8] <em>/<br></code></pre><br><ul><br><li><code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</li><br></ul><br><pre><code class="javascript">[1, 2, 3, 4, 5].copyWithin(0, 3)<br>/</em> [4, 5, 3, 4, 5] <em>/<br></code></pre><br><ul><br><li>find() 和 findIndex()</li><br></ul><br><p><code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>.</p><br><pre><code class="javascript">[1, 5, 10, 15].find(function(value) {<br>  return value &gt; 9;<br>})　/</em> 10 <em>/<br></code></pre><br><p>findIndex方法返回第一个符合条件的数组成员的下标，否则则返回<code>-1</code></p><br><pre><code class="javascript">[1, 5, 10, 15].findIndex(function(value, index, arr) {<br>  return value &gt; 9;<br>}) /</em> 2 <em>/<br></code></pre><br><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象.另外，这两个方法借助Object.is(),可以发现<code>NaN</code></p><br><pre><code class="javascript">[NaN].indexOf(NaN)<br>/</em> -1 <em>/<br>[NaN].findIndex(y =&gt; Object.is(NaN, y))<br>/</em> 0 <em>/<br></code></pre><br><ul><br><li>fill(): 方法使用给定值，填充一个数组。</li><br></ul><br><pre><code class="javascript">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)<br>/</em> [7, 7, 7] <em>/<br>new Array(3).fill(7)<br>/</em> [7, 7, 7] <em>/<br></code></pre><br><ul><br><li>entries(), keys(), values(), 都用于遍历数组，都返回一个遍历器对象．借助for of 进行循环遍历．</li><br></ul><br><p>区别是keys()是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p><br><pre><code class="javascript">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {<br>  console.log(index);<br>}<br>/</em> 0 <em>/<br>/</em> 1 <em>/<br>for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {<br>  console.log(elem);<br>}<br>/</em> &#39;a&#39; <em>/<br>/</em> &#39;b&#39; <em>/<br>for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {<br>  console.log(index, elem);<br>}<br>/</em> 0 &quot;a&quot; <em>/<br>/</em> 1 &quot;b&quot; <em>/<br></code></pre><br><h4 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h4><hr><br><p><strong>参数默认值</strong></p><br><ul><br><li>指定参数默认值．</li><br><li>参数默认值的位置：　最好是函数的尾参数，否则会有很多不必要的问题．</li><br><li>函数的<code>length</code>属性：　指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</li><br><li>参数作用域：　一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</li><br></ul><br><pre><code class="javascript">let x = 1;<br>function f(y = x) {<br>  let x = 2;<br>  console.log(y);<br>}<br>f() /</em> 1 <em>/<br></code></pre><br><p><strong>rest参数</strong></p><br><ul><br><li>和扩展运算符(…varia)比较像但作用相反．用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了．</li><br></ul><br><pre><code class="javascript">function add(…values) {<br>  let sum = 0;<br>  for (var val of values) {<br>    sum += val;<br>  }<br>  return sum;<br>}<br>add(2, 5, 3) // 10<br></code></pre><br><ul><br><li>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</li><br><li>函数的<code>length</code>属性，不包括 rest 参数。</li><br></ul><br><p><strong>扩展运算符</strong></p><br><ul><br><li>就是三个点(．．．)，将一个数组转为用逗号分隔的参数序列。即，展开数组</li><br></ul><br><pre><code class="javascript">console.log(1, …[2, 3, 4], 5)<br>/</em> 1 2 3 4 5 <em>/<br></code></pre><br><p><strong>严格模式</strong></p><br><p>从ES5开始，函数内部可以设定为严格模式. ES6做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错.</p><br><p><strong>箭头函数(重点来咯)</strong></p><br><pre><code class="javascript">var f = v =&gt; v;<br>/</em> 等同于 <em>/<br>var f = function(v) {<br>  return v;<br>};<br><br>/</em> 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分 <em>/<br>var f = () =&gt; 5;<br>/</em> 等同于 <em>/<br>var f = function () { return 5 };<br><br>var sum = (num1, num2) =&gt; num1 + num2;<br>/</em> 等同于 <em>/<br>var sum = function(num1, num2) {<br>  return num1 + num2;<br>};<br><br>/</em> 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用显式return语句返回 <em>/<br>var sum = (num1, num2) =&gt; { return num1 + num2; }<br><br>/</em> 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 <em>/<br>var getTempItem = () =&gt; {let id = 1; return ({ id: id, name: &quot;Temp&quot; })};<br></code></pre><br><ul><br><li>变量解构和rest参数都可以和箭头函数结合．</li><br></ul><br><p><strong>注意：</strong></p><br><ol><br><li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li><br><li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li><br><li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。</li><br><li>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</li><br></ol><br><p>第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p><br><pre><code class="javascript">function foo() {<br>  setTimeout(() =&gt; {<br>    console.log(&#39;id:&#39;, this.id);<br>  }, 100);<br>}<br><br>var id = 21;<br><br>foo.call({ id: 42 });<br>/</em> id: 42 <em>/<br></code></pre><br><p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数．</p><br><pre><code class="javascript">/</em> ES6 <em>/<br>function foo() {<br>  setTimeout(() =&gt; {<br>    console.log(&#39;id:&#39;, this.id);<br>  }, 100);<br>}<br>/</em> 背后实现相当于下面这个 <em>/<br>/</em> ES5 <em>/<br>function foo() {<br>  var _this = this;<br>  setTimeout(function () {<br>    console.log(&#39;id:&#39;, _this.id);<br>  }, 100);<br>}<br></code></pre><br><p>上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</p><br><p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，其实都指向的是外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code></p><br><pre><code class="javascript">function foo() {<br>  setTimeout(() =&gt; {<br>    console.log(&#39;args:&#39;, arguments);<br>  }, 100);<br>}<br>foo(2, 4, 6, 8)<br>/</em> args: [2, 4, 6, 8] <em>/<br></code></pre><br><p>由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向</p><br><p><strong>尾调用</strong></p><br><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是返回另一个函数。</p><br><pre><code class="javascript">function f(x){<br>  return g(x);<br>}<br>/</em> 下面三个都不属于尾调用　<em>/<br>function f(x){<br>  let y = g(x);<br>  return y;<br>}<br>function f(x){<br>  return g(x) + 1;<br>}<br>function f(x){<br>  g(x);<br>}<br></code></pre><br><p><strong>尾调用优化</strong></p><br><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><br><p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><br><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了</p><br><pre><code class="javascript">function f() {<br>  let m = 1;<br>  let n = 2;<br>  return g(m + n);<br>}<br>f();<br>/</em> 等同于 <em>/<br>function f() {<br>  return g(3);<br>}<br>f();<br>/</em> 等同于 <em>/<br>g(3);<br></code></pre><br><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</p><br><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><br><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><br><pre><code class="javascript">function addOne(a){<br>  var one = 1;<br>  function inner(b){<br>    return b + one;<br>  }<br>  return inner(a);<br>}<br></code></pre><br><p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p><br><p><strong>尾递归</strong></p><br><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p><br><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p><br><pre><code class="javascript">function factorial(n) {<br>  if (n === 1) return 1;<br>  return n </em> factorial(n - 1);<br>}<br>factorial(5) /<em> 120 </em>/<br></code></pre><br><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p><br><p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><br><pre><code class="javascript">function factorial(n, total) {<br>  if (n === 1) return total;<br>  return factorial(n - 1, n <em> total);<br>}<br>factorial(5, 1) /</em> 120 <em>/<br></code></pre><br><p>但一般这样做尾递归的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p><br><p><em>两个方法可以解决这个问题．</em></p><br><p>方法一是在尾递归函数之外，再提供一个正常形式的函数。</p><br><pre><code class="javascript">function tailFactorial(n, total) {<br>  if (n === 1) return total;<br>  return tailFactorial(n - 1, n </em> total);<br>}<br>function factorial(n) {<br>  return tailFactorial(n, 1);<br>}<br>factorial(5) /<em> 120 </em>/<br></code></pre><br><p>第二种方法就简单多了，就是采用ES6的函数默认值。</p><br><pre><code class="javascript">function factorial(n, total = 1) {<br>  if (n === 1) return total;<br>  return factorial(n - 1, n <em> total);<br>}<br><br>factorial(5) // 120<br></code></pre><br><blockquote><br><p>总结:  递归本质上是一种循环操作.能用循环代替递归就用循环，否则最好使用尾递归．</p><br></blockquote><br><p><strong>严格模式</strong></p><br><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><br><p>func.arguments, func.caller</p><br><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><br><h4 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h4><hr><br><p><strong>属性的间接表示法:</strong>  允许直接写入变量和函数，作为对象的属性和方法。</p><br><pre><code class="javascript">var foo = &#39;bar&#39;;<br>var baz = {foo};<br>baz /</em> {foo: &quot;bar&quot;} <em>/<br>/</em> 等同于 <em>/<br>var baz = {foo: foo};<br><br>function f(x, y) {<br>  return {x, y};<br>}<br>/</em> 等同于 <em>/<br>function f(x, y) {<br>  return {x: x, y: y};<br>}<br>f(1, 2) /</em> Object {x: 1, y: 2} <em>/<br></code></pre><br><p>除了属性简写，方法也可以简写</p><br><pre><code class="javascript">var o = {<br>  method() {<br>    return &quot;Hello!&quot;;<br>  }<br>};<br>/</em> 等同于 <em>/<br>var o = {<br>  method: function() {<br>    return &quot;Hello!&quot;;<br>  }<br>};<br></code></pre><br><p><strong>属性名表达式</strong></p><br><p>如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用标识符定义属性。</p><br><pre><code class="javascript">var obj = {<br>  foo: true,<br>  abc: 123<br>};<br>/</em> ES6允许把表达式和变量放在方括号内。 <em>/<br>let propKey = &#39;foo&#39;;<br>let obj = {<br>  [propKey]: true,<br>  [&#39;a&#39; + &#39;bc&#39;]: 123<br>};<br>/</em> 表达式和变量还可以用于定义方法名 <em>/<br>let prop = &#39;what&#39;;<br>let obj = {<br>  <a href="">&#39;h&#39; + &#39;ello&#39;</a> {<br>    return &#39;hi&#39;;<br>  },<br>  <a href="">prop</a>{<br>    console.log(&#39;the hell&#39;);<br>  }<br>};<br>obj.hello() /</em> hi <em>/<br>obj.what() /</em> the hell <em>/<br></code></pre><br><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><br><pre><code class="javascript">/</em> 报错 <em>/<br>var foo = &#39;bar&#39;;<br>var baz = { [foo] };<br></code></pre><br><p><strong>Object.is()</strong></p><br><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code></p><br><p>Object.is() 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致.不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身.</p><br><p><strong>Object.assign()</strong></p><br><p>用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）</p><br><pre><code class="javascript">var target = { a: 1 };<br>var source1 = { b: 2 };<br>var source2 = { c: 3 };<br><br>Object.assign(target, source1, source2);<br>target /</em> {a:1, b:2, c:3} */<br></code></pre><br><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><br><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><br><p><strong>属性的遍历</strong></p><br><p><em>for…in</em>：　循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）</p><br><p><em>Object.keys</em>　返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p><br><p><em>Object.getOwnPropertyNames</em>：　返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p><br><p><em>Object.getOwnPropertySymbols</em>：　返回一个数组，包含对象自身的所有Symbol属性。</p><br><p><em>Reflect.ownKeys</em>：　返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p><br><p><strong>Object.keys(), Object,values(), Object.entries()</strong></p><br><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</p><br><p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="external">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for…of</code>循环使用。</p><br><p><em>Object.values</em>　方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值</p><br><p><em>Object.entries</em>　方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组</p><br><hr><br><p><code>精简版ES6上半部分完成．．．</code></p>
</section></div><script src="/js/jquery.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/start.js"></script></body></html>