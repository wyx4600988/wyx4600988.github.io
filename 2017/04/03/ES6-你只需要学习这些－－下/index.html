<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="yes" name="apple-touch-fullscreen"><meta content="telephone=no,email=no" name="format-detection"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet"><script src="https://use.fontawesome.com/adaf0e149c.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/monokai_sublime.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/markdown-github.css"><title>林水溶的博客</title><script src="/js/googleAnalytics.js"></script></head><body><div id="postContainer"><div id="postTop"><h4 id="logo">Life Is Short</h4><br><br><h2 id="postTitle">ES6,你只需要学习这些－－下</h2><br><span aria-hidden="true" class="postTime fa fa-calendar">2017-4-3</span><span aria-hidden="true" class="postTags fa fa-tags">&nbsp;前端</span><span aria-hidden="true" class="postTags fa fa-tags">&nbsp;ES6</span><br><br></div><section id="articleDiv"><p>本篇包括这些特性：</p><br><pre><code class="javascript">Symbol, Set和Map数据结构, Proxy, Reflect, Iterator和for..of, Generator函数, async函数, Class, Decorator, Module语法, Module的加载实现<br></code></pre><br><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><hr><br><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><br><p><strong>产生原因：</strong>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。</p><br><p>Symbol值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><br><pre><code class="javascript">let s = Symbol();<br>typeof s<br>/<em> &quot;symbol&quot; </em>/<br></code></pre><br><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。</p><br><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><br><pre><code class="javascript">var s1 = Symbol(&#39;foo&#39;);<br>s1 /<em> Symbol(foo) </em>/<br>s1.toString() /<em> &quot;Symbol(foo)&quot; </em>/<br></code></pre><br><ul><br><li>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</li><br><li>Symbol值不能与其他类型的值进行运算，会报错。</li><br><li>但是，Symbol值可以显式转为字符串。</li><br></ul><br><pre><code class="javascript">var sym = Symbol(&#39;My symbol&#39;);<br>String(sym) /<em> &#39;Symbol(My symbol)&#39; </em>/<br>sym.toString() /<em> &#39;Symbol(My symbol)&#39; </em>/<br></code></pre><br><ul><br><li>另外，Symbol值也可以转为布尔值，但是不能转为数值。</li><br></ul><br><p><strong>作为属性名的Symbol</strong></p><br><pre><code class="javascript">var mySymbol = Symbol();<br>/<em> 第一种写法 </em>/<br>var a = {};<br>a[mySymbol] = &#39;Hello!&#39;;<br>/<em> 第二种写法 </em>/<br>var a = {<br>  [mySymbol]: &#39;Hello!&#39;<br>};<br>/<em> 第三种写法 </em>/<br>var a = {};<br>Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });<br>/<em> 以上写法都得到同样结果 </em>/<br>a[mySymbol] /<em> &quot;Hello!&quot; </em>/<br>/<em> 注意，Symbol值作为对象属性名时，不能用点运算符。 </em>/<br>a.mySymbol = &#39;Hello!&#39;;  /<em> 会将mySymbol转换成字符串　</em>/<br></code></pre><br><p><strong>Symbol.for(), Symbol.keyFor()</strong></p><br><p>有时，我们希望重新使用同一个Symbol值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值</p><br><pre><code class="javascript">var s1 = Symbol.for(&#39;foo&#39;);<br>var s2 = Symbol.for(&#39;foo&#39;);<br>s1 === s2 /<em> true </em>/<br></code></pre><br><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在<strong>全局环境</strong>中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30次，会返回30个不同的Symbol值。</p><br><p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><br><pre><code class="javascript">var s1 = Symbol.for(&quot;foo&quot;);<br>Symbol.keyFor(s1) /<em> &quot;foo&quot; </em>/<br>var s2 = Symbol(&quot;foo&quot;);<br>Symbol.keyFor(s2) /<em> undefined </em>/<br></code></pre><br><h4 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h4><hr><br><p><strong>Set</strong></p><br><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><br><pre><code class="javascript">/<em> 例一 </em>/<br>var set = new Set([1, 2, 3, 4, 4]);<br>[…set]<br>/<em> [1, 2, 3, 4] </em>/<br>/<em> 例二 </em>/<br>var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);<br>items.size /<em> 5 </em>/<br></code></pre><br><p><em>操作方法：</em></p><br><ul><br><li><code>add(value)</code>：添加某个值，返回Set结构本身。</li><br><li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><br><li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><br><li><code>clear()</code>：清除所有成员，没有返回值。</li><br></ul><br><p><em>遍历方法：</em></p><br><ul><br><li><code>keys()</code>：返回键名的遍历器</li><br><li><code>values()</code>：返回键值的遍历器</li><br><li><code>entries()</code>：返回键值对的遍历器</li><br><li><code>forEach()</code>：使用回调函数遍历每个成员</li><br></ul><br><p><strong>Map</strong></p><br><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键.也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现</p><br><p><em>操作方法:</em></p><br><ul><br><li>set(key,value)：返回整个Map结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li><br><li>get(key)：方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code></li><br><li>has(key)：方法返回一个布尔值，表示某个键是否在Map数据结构中</li><br><li>delete(key)：方法删除某个键，返回true。如果删除失败，返回false</li><br><li>clear()：方法清除所有成员，没有返回值</li><br></ul><br><p><em>遍历方法：</em></p><br><ul><br><li><code>keys()</code>：返回键名的遍历器。</li><br><li><code>values()</code>：返回键值的遍历器。</li><br><li><code>entries()</code>：返回所有成员的遍历器。</li><br><li><code>forEach()</code>：遍历Map的所有成员。</li><br></ul><br><p><em>与其他数据结构的转换:</em></p><br><ol><br><li>Map和数组互转</li><br><li>Map和对象互转</li><br><li>Map和JSON互转</li><br></ol><br><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><hr><br><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写</p><br><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><br><pre><code class="javascript">var proxy = new Proxy(target, handler);<br></code></pre><br><p>其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为.</p><br><pre><code class="javascript">var obj = new Proxy({}, {<br>  get: function (target, key, receiver) {<br>    console.log(<code>getting ${key}!</code>);<br>    return Reflect.get(target, key, receiver);<br>  },<br>  set: function (target, key, value, receiver) {<br>    console.log(<code>setting ${key}!</code>);<br>    return Reflect.set(target, key, value, receiver);<br>  }<br>});<br><br>obj.count = 1<br>/<em>  setting count! </em>/<br>++obj.count<br>/<em>  getting count! </em>/<br>/<em>  setting count! </em>/<br>/<em>  2 </em>/<br></code></pre><br><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><br><p>下面是 Proxy 支持的拦截操作一览:</p><br><p>get(target, propKey, receiver), set(target, propKey, value, receiver), has(target, propKey), deleteProperty(target, propKey) . . . </p><br><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><hr><br><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p><br><p>将<code>Object</code>对象的一些明显属于语言内部的方法，放到<code>Reflect</code>对象上.</p><br><p>. . .</p><br><h4 id="Promise-重点"><a href="#Promise-重点" class="headerlink" title="Promise(重点)"></a>Promise(重点)</h4><hr><br><p>Promise 是异步编程的一种解决方案．ES6将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象．</p><br><p><code>Promise</code>对象有以下两个特点。</p><br><ol><br><li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><br><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>Pending</code>变为<code>Resolved</code>和从<code>Pending</code>变为<code>Rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li><br></ol><br><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</p><br><p><strong>基本用法</strong></p><br><p>Promise对象是一个构造函数，用来生成Promise实例</p><br><pre><code class="javascript">var promise = new Promise(function(resolve, reject) {<br>  /<em> … some code </em>/<br>  if (/<em> 异步操作成功 </em>/){<br>    resolve(value);<br>  } else {<br>    reject(error);<br>  }<br>});<br></code></pre><br><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p><br><p><code>resolve</code>函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</p><br><p>Promise实例生成以后，可以用<code>then</code>方法分别指定<code>Resolved</code>状态和<code>Reject</code>状态的回调函数</p><br><pre><code class="javascript">promise.then(function(value) {<br>  /<em> success </em>/<br>}, function(error) {<br>  /<em> failure </em>/<br>});<br></code></pre><br><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数</p><br><pre><code class="javascript">/<em> 简单例子　</em>/<br>function timeout(ms) {<br>  return new Promise((resolve, reject) =&gt; {<br>    setTimeout(resolve, ms, &#39;done&#39;);<br>  });<br>}<br>timeout(100).then((value) =&gt; {<br>  console.log(value);<br>});<br></code></pre><br><p>Promise新建后就会立即执行。</p><br><pre><code class="javascript">let promise = new Promise(function(resolve, reject) {<br>  console.log(&#39;Promise&#39;);<br>  resolve();<br>});<br>promise.then(function() {<br>  console.log(&#39;Resolved.&#39;);<br>});<br>console.log(&#39;Hi!&#39;);<br>/<em> Promise </em>/<br>/<em> Hi! </em>/<br>/<em> Resolved </em>/<br></code></pre><br><p><code>resolve</code>函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p><br><pre><code class="javascript">var p1 = new Promise(function (resolve, reject) {<br>  /<em> … </em>/<br>});<br><br>var p2 = new Promise(function (resolve, reject) {<br>  /<em> … </em>/<br>  resolve(p1);<br>})<br></code></pre><br><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>Pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>Resolved</code>或者<code>Rejected</code>，那么<code>p2</code>的回调函数将会立刻执行</p><br><pre><code class="javascript">var p1 = new Promise(function (resolve, reject) {<br>  setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000)<br>})<br><br>var p2 = new Promise(function (resolve, reject) {<br>  setTimeout(() =&gt; resolve(p1), 1000)<br>})<br><br>p2<br>  .then(result =&gt; console.log(result))<br>  .catch(error =&gt; console.log(error))<br>/<em> Error: fail </em>/<br></code></pre><br><p>上面代码中，<code>p1</code>是一个Promise，3秒之后变为<code>rejected</code>。<code>p2</code>的状态在1秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了2秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数</p><br><p><strong>Promise.prototype.then()</strong></p><br><p><code>then</code>方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><br><pre><code class="javascript">getJSON(&quot;/post/1.json&quot;).then(<br>  post =&gt; getJSON(post.commentURL)<br>).then(<br>  comments =&gt; console.log(&quot;Resolved: &quot;, comments),<br>  err =&gt; console.log(&quot;Rejected: &quot;, err)<br>);<br></code></pre><br><p><strong>Promise.prototype.catch()</strong></p><br><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><br><p><strong>Promise.prototype.all()</strong></p><br><p><code>Promise.all</code>方法用于将多个Promise实例，包装成一个新的Promise实例</p><br><pre><code class="javascript">var p = Promise.all([p1, p2, p3]);<br></code></pre><br><p><code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是Promise对象的实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为Promise实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）</p><br><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><br><ol><br><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li><br><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</li><br></ol><br><pre><code class="javascript">/<em> 生成一个Promise对象的数组 </em>/<br>var promises = [2, 3, 5, 7, 11, 13].map(function (id) {<br>  return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;);<br>});<br><br>Promise.all(promises).then(function (posts) {<br>  /<em> … </em>/<br>}).catch(function(reason){<br>  /<em> … </em>/<br>});<br></code></pre><br><p><strong>Promise.prototype.race()</strong></p><br><p>同样是将多个Promise实例，包装成一个新的Promise实例。</p><br><pre><code class="javascript">var p = Promise.race([p1, p2, p3]);<br></code></pre><br><p>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数</p><br><p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</p><br><pre><code class="javascript">const p = Promise.race([<br>  fetch(&#39;/resource-that-may-take-a-while&#39;),<br>  new Promise(function (resolve, reject) {<br>    setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000)<br>  })<br>]);<br>p.then(response =&gt; console.log(response));<br>p.catch(error =&gt; console.log(error));<br></code></pre><br><p>上面代码中，如果5秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数</p><br><p><strong>Promise.prototype.resolve()</strong></p><br><p>有时需要将现有对象转为Promise对象，<code>Promise.resolve</code>方法就起到这个作用</p><br><pre><code class="javascript">var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));<br></code></pre><br><p><code>Promise.resolve</code>等价于下面的写法。</p><br><pre><code class="javascript">Promise.resolve(&#39;foo&#39;)<br>/<em> 等价于 </em>/<br>new Promise(resolve =&gt; resolve(&#39;foo&#39;))<br></code></pre><br><p><code>Promise.resolve</code>方法的参数分成四种情况。</p><br><ol><br><li>一个Promise实例：那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li><br><li>一个thenable对象：<code>thenable</code>对象指的是具有<code>then</code>方法的对象</li><br></ol><br><p><code>Promise.resolve</code>方法会将这个对象转为Promise对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法</p><br><pre><code class="javascript">let thenable = {<br>  then: function(resolve, reject) {<br>    resolve(42);<br>  }<br>};<br>let p1 = Promise.resolve(thenable);<br>p1.then(function(value) {<br>  console.log(value);  /<em> 42 </em>/<br>});<br></code></pre><br><ol><br><li>参数不是具有then方法的对象，或根本就不是对象</li><br></ol><br><p><code>Promise.resolve</code>方法返回一个新的Promise对象，状态为<code>Resolved</code></p><br><pre><code class="javascript">var p = Promise.resolve(&#39;Hello&#39;);<br>p.then(function (s){<br>  console.log(s)<br>});<br>/<em> Hello </em>/<br></code></pre><br><ol><br><li>不带有任何参数</li><br></ol><br><p>直接返回一个<code>Resolved</code>状态的Promise对象。</p><br><p>需要注意的是，立即<code>resolve</code>的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时</p><br><pre><code class="javascript">setTimeout(function () {<br>  console.log(&#39;three&#39;);<br>}, 0);<br>Promise.resolve().then(function () {<br>  console.log(&#39;two&#39;);<br>});<br>console.log(&#39;one&#39;);<br>/<em> one </em>/<br>/<em> two </em>/<br>/<em> three </em>/<br></code></pre><br><p><strong>Promise.prototype.reject()</strong></p><br><p>返回一个新的 Promise 实例，该实例的状态为<code>rejected</code></p><br><p>注意，<code>Promise.reject()</code>方法的参数，会原封不动地变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p><br><pre><code class="javascript">const thenable = {<br>  then(resolve, reject) {<br>    reject(&#39;出错了&#39;);<br>  }<br>};<br>Promise.reject(thenable)<br>.catch(e =&gt; {<br>  console.log(e === thenable)<br>})<br>/<em> true </em>/<br></code></pre><br><p><strong>Promise.prototype.try()</strong></p><br><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法</p><br><pre><code class="javascript">Promise.resolve().then(f)<br></code></pre><br><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行</p><br><pre><code class="javascript">const f = () =&gt; console.log(&#39;now&#39;);<br>Promise.resolve().then(f);<br>console.log(&#39;next&#39;);<br>/<em> next </em>/<br>/<em> now </em>/<br></code></pre><br><h4 id="Iterator和for…of"><a href="#Iterator和for…of" class="headerlink" title="Iterator和for…of"></a>Iterator和for…of</h4><hr><br><p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。Iterator(遍历器)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><br><p><strong>Iterator的作用有三个：</strong></p><br><ol><br><li>为各种数据结构，提供一个统一的、简便的访问接口</li><br><li>使得数据结构的成员能够按某种次序排列</li><br><li>ES6创造了一种新的遍历命令<code>for…of</code>循环，Iterator接口主要供<code>for…of</code>消费。</li><br></ol><br><p><strong>Iterator的遍历过程是这样的：</strong></p><br><ol><br><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象</li><br><li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li><br><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><br><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li><br></ol><br><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><br><pre><code class="javascript">var it = makeIterator([&#39;a&#39;, &#39;b&#39;]);<br>it.next() /<em> { value: &quot;a&quot;, done: false } </em>/<br>it.next() /<em> { value: &quot;b&quot;, done: false } </em>/<br>it.next() /<em> { value: undefined, done: true } </em>/<br><br>function makeIterator(array) {<br>  var nextIndex = 0;<br>  return {<br>    next: function() {<br>      return nextIndex &lt; array.length ?<br>        {value: array[nextIndex++], done: false} :<br>        {value: undefined, done: true};<br>    }<br>  };<br>}<br></code></pre><br><p><strong>for…of</strong>　</p><br><ol><br><li>遍历value.</li><br><li>可以与break, continue, return 配合使用．</li><br><li>提供了遍历所有数据结构的统一操作接口</li><br><li>​</li><br></ol><br><p><strong>for…in</strong>　</p><br><ol><br><li>遍历key</li><br><li>缺点：　不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><br></ol><br><h4 id="Generator函数语法"><a href="#Generator函数语法" class="headerlink" title="Generator函数语法"></a>Generator函数语法</h4><hr><br><p><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">本章及　Generator应用　及async函数　应该是这本书最难也是最重要的部分，我看了两遍才明白怎么回事儿．没法精简，诸君去看书的对应章节吧</a></p><br><h3 id="Class-重点"><a href="#Class-重点" class="headerlink" title="Class(重点)"></a>Class(重点)</h3><hr><br><p>ES5的生成新对象的写法和传统的面向对象语言差异很大．</p><br><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。基本上，ES6的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><br><pre><code class="javascript">/<em> 定义类 </em>/<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>  toString() {<br>    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;<br>  }<br>}<br></code></pre><br><p><code>constructor</code>方法，这就是构造方法,<code>this</code>关键字则代表实例对象</p><br><p>注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字.另外，方法之间不需要逗号分隔.</p><br><pre><code class="javascript">/<em> Class的使用　</em>/<br>class Bar {<br>  doStuff() {<br>    console.log(&#39;stuff&#39;);<br>  }<br>}<br>var b = new Bar();<br>b.doStuff() /<em> &quot;stuff&quot; </em>/<br></code></pre><br><p>类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致.</p><br><p>类的方法名，可以采用表达式。</p><br><p><strong>constructor方法</strong></p><br><p>是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><br><p>类的构造函数，不使用<code>new</code>是没法调用的，会报错.</p><br><p><strong>类的实例对象</strong></p><br><p>与ES5一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）</p><br><p>与ES5一样，类的所有实例共享一个原型对象。</p><br><p>Class不存在变量提升（hoist），这一点与ES5完全不同</p><br><pre><code class="javascript">new Foo(); /<em> ReferenceError </em>/<br>class Foo {}<br></code></pre><br><p><strong>Class表达式</strong></p><br><p>与函数一样，类也可以使用表达式的形式定义.</p><br><p><strong>私有方法</strong></p><br><p>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现.比较好的办法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值</p><br><pre><code class="javascript">const t = Symbol(&#39;bar&#39;);<br>const snaf = Symbol(&#39;snaf&#39;);<br><br>export default class myClass{<br>  /<em> 公有方法 </em>/<br>  foo() {<br>    console.log(1);<br>    this[t];<br>  }<br>  /<em> 私有方法 </em>/<br>  <a href="">t</a> {<br>    console.log(2);<br>  }<br>};<br></code></pre><br><p><strong>this</strong></p><br><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例.但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><br><pre><code class="javascript">class Logger {<br>  printName(name = &#39;there&#39;) {<br>    this.print(<code>Hello ${name}</code>);<br>  }<br>  print(text) {<br>    console.log(text);<br>  }<br>}<br>const logger = new Logger();<br>const { printName } = logger;<br>printName(); // TypeError: Cannot read property &#39;print&#39; of undefined<br></code></pre><br><p>如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，所以找不到<code>print</code>方法而导致报错．</p><br><p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><br><pre><code class="javascript">class Logger {<br>  constructor() {<br>    this.printName = this.printName.bind(this);<br>  }<br>}<br></code></pre><br><p>另一种解决方法是使用箭头函数。</p><br><pre><code class="javascript">class Logger {<br>  constructor() {<br>    this.printName = (name = &#39;there&#39;) =&gt; {<br>      this.print(<code>Hello ${name}</code>);<br>    };<br>  }<br>}<br></code></pre><br><p><strong>严格模式</strong></p><br><p>类和模块的内部，默认就是严格模式</p><br><p><strong>类的继承</strong></p><br><p>通过<code>extends</code>关键字实现继承</p><br><pre><code class="javascript">class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); /<em> 调用父类的constructor(x, y) </em>/<br>    this.color = color;<br>  }<br><br>  toString() {<br>    return this.color + &#39; &#39; + super.toString(); /<em> 调用父类的toString() </em>/<br>  }<br>}<br></code></pre><br><p>类必须在<code>constructor</code>方法中调用<code>super</code>方法，且位于最上方．</p><br><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加．如下：</p><br><pre><code class="javascript">constructor(…args) {<br>  super(…args);<br>}<br></code></pre><br><p><strong>Object.getPrototypeOf</strong></p><br><p>可以用来从子类上获取父类。</p><br><pre><code class="javascript">Object.getPrototypeOf(ColorPoint) === Point<br>/<em> true  用这个方法判断，一个类是否继承了另一个类</em>/<br></code></pre><br><p><strong>super</strong></p><br><p>既可以当作函数使用，也可以当作对象使用.</p><br><p>ES6 规定，通过<code>super</code>调用父类的方法时，<code>super</code>会绑定子类的<code>this</code>。</p><br><ul><br><li><code>super</code>作为函数调用时，代表父类的构造函数.且只能用在子类的构造函数中．</li><br><li><code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</li><br></ul><br><p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的.</p><br><pre><code class="javascript">class A {<br>  constructor() {<br>    this.p = 2;<br>  }<br>}<br><br>class B extends A {<br>  get m() {<br>    return super.p;<br>  }<br>}<br>let b = new B();<br>b.m /<em> undefined </em>/<br>/<em> 如果属性定义在父类的原型对象上，super就可以取到 </em>/<br>class A {}<br>A.prototype.x = 2;<br><br>class B extends A {<br>  constructor() {<br>    super();<br>    console.log(super.x) /<em> 2 </em>/<br>  }<br>}<br><br>let b = new B();<br></code></pre><br><p><strong>原生构造函数的继承</strong></p><br><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构.以前，这些原生构造函数是无法继承的.ES6允许可以继承．</p><br><p><strong>静态方法</strong></p><br><p>如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><br><pre><code class="javascript">class Foo {<br>  static classMethod() {<br>    return &#39;hello&#39;;<br>  }<br>}<br>Foo.classMethod() /<em> &#39;hello&#39; </em>/<br><br>var foo = new Foo();<br>foo.classMethod()<br>/<em> TypeError: foo.classMethod is not a function </em>/<br></code></pre><br><p>父类的静态方法，可以被子类继承。</p><br><p>静态方法也可以从<code>super</code>对象上调用.</p><br><h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><hr><br><p><a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案．</a></p><br><h4 id="Module语法-重点"><a href="#Module语法-重点" class="headerlink" title="Module语法(重点)"></a>Module语法(重点)</h4><hr><br><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><br><p><strong>严格模式</strong></p><br><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><br><p><strong>export</strong></p><br><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能</p><br><pre><code class="javascript">/<em> profile.js </em>/<br>export var firstName = &#39;Michael&#39;;<br>export var lastName = &#39;Jackson&#39;;<br>export var year = 1958;<br><br>/<em> profile.js 另一种写法　</em>/<br>var firstName = &#39;Michael&#39;;<br>var lastName = &#39;Jackson&#39;;<br>var year = 1958;<br>export {firstName, lastName, year};<br></code></pre><br><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）</p><br><pre><code class="javascript">export function multiply(x, y) {<br>  return x <em> y;<br>};<br>/</em> 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。<em>/<br>function v1() { … }<br>function v2() { … }<br>export {<br>  v1 as streamV1,<br>  v2 as streamV2,<br>  v2 as streamLatestVersion<br>};<br>/</em> 重命名后，v2可以用不同的名字输出两次。<em>/<br></code></pre><br><p><code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><br><pre><code class="javascript">/</em> 报错 <em>/<br>export 1;<br>/</em> 报错 <em>.<br>var m = 1;<br>export m;<br><br>/</em> 正确的写法 <em>/<br>/</em> 写法一 <em>/<br>export var m = 1;<br>/</em> 写法二 <em>/<br>var m = 1;<br>export {m};<br>/</em> 写法三 <em>/<br>var n = 1;<br>export {n as m};<br></code></pre><br><p><code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><br><p>另外，<code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><br><pre><code class="javascript">export var foo = &#39;bar&#39;;<br>setTimeout(() =&gt; foo = &#39;baz&#39;, 500);<br>/</em> 其实导出的是foo = &#39;baz&#39;; <em>/<br></code></pre><br><p>最后，<code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。</p><br><p><strong>import</strong></p><br><pre><code class="javascript">/</em> main.js <em>/<br>import {firstName, lastName, year} from &#39;./profile&#39;;<br>function setName(element) {<br>  element.textContent = firstName + &#39; &#39; + lastName;<br>}<br></code></pre><br><p>同样能用as关键词重命名</p><br><pre><code class="javascript">import { lastName as surname } from &#39;./profile&#39;;<br></code></pre><br><ul><br><li>模块名没有路径的话，配置文件里必须得有．</li><br><li>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行</li><br><li>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</li><br><li>如果多次重复执行同一句<code>import</code>语句，那么只会执行一次</li><br></ul><br><p><strong>模块的整体加载</strong></p><br><pre><code class="javascript">/</em> main.js <em>/<br>import { area, circumference } from &#39;./circle&#39;;<br>console.log(&#39;圆面积：&#39; + area(4));<br>console.log(&#39;圆周长：&#39; + circumference(14));<br>/</em> index.js <em>/<br>import </em> as circle from &#39;./circle&#39;;<br>console.log(&#39;圆面积：&#39; + circle.area(4));<br>console.log(&#39;圆周长：&#39; + circle.circumference(14));<br></code></pre><br><p><strong>export default</strong></p><br><p>从前面的例子可以看出，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><br><p><code>export default</code>命令，为模块指定默认输出.</p><br><pre><code class="javascript">/<em> export-default.js </em>/<br>export default function () {<br>  console.log(&#39;foo&#39;);<br>}<br></code></pre><br><p>注意，这时<code>import</code>命令后面，不使用大括号。</p><br><pre><code class="javascript">/<em> export-default.js </em>/<br>export default function foo() {<br>  console.log(&#39;foo&#39;);<br>}<br>/<em> 或者写成 </em>/<br>function foo() {<br>  console.log(&#39;foo&#39;);<br>}<br>export default foo;<br></code></pre><br><p>上面代码中，<code>foo</code>函数的函数名<code>foo</code>，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><br><ul><br><li>一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次</li><br><li>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</li><br></ul><br><pre><code class="javascript">/<em> modules.js </em>/<br>function add(x, y) {<br>  return x <em> y;<br>}<br>export {add as default};<br>/</em> 等同于 <em>/<br>/</em> export default add; <em>/<br><br>/</em> app.js <em>/<br>import { default as xxx } from &#39;modules&#39;;<br>/</em> 等同于 <em>/<br>/</em> import xxx from &#39;modules&#39;; <em>/<br></code></pre><br><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p><br><pre><code class="javascript">import _ from &#39;lodash&#39;;<br></code></pre><br><p><strong>export和import的复合写法</strong></p><br><pre><code class="javascript">export { foo, bar } from &#39;my_module&#39;;<br>/</em> 等同于 */<br>import { foo, bar } from &#39;my_module&#39;;<br>export { foo, bar };<br></code></pre><br><h4 id="Module的加载实现"><a href="#Module的加载实现" class="headerlink" title="Module的加载实现"></a>Module的加载实现</h4><hr><br><p><strong>浏览器加载</strong></p><br><pre><code class="html">&lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt;<br></code></pre><br><p>所有模块都是异步加载，等到页面渲染完才执行模块脚本．相当于添加了async属性．</p><br><p>对于外部模块脚本，几点注意的：</p><br><ul><br><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><br><li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code></li><br><li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li><br><li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的</li><br><li>同一个模块如果加载多次，将只执行一次</li><br></ul><br><p><strong>ES6模块与CommonJS模块的差异</strong></p><br><p>两个重大差异</p><br><ul><br><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用(相关接口的地址)</li><br><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li><br></ul><br><p>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p><br><p><strong>Node加载</strong></p><br><p>Node有自己的CommonJS模块格式，与ES6模块格式不兼容．</p><br><p>想在Node端使用ES6模的话只能用<a href="https://github.com/benjamn/reify" target="_blank" rel="external">黑魔法</a>或者Babel或者可以自动处理import语法的打包工具．</p><br><hr><br><p><code>编程风格，二进制数组等章节，有需求的同学出门左转原书里看去吧．</code></p>
</section></div><script src="/js/jquery.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/start.js"></script></body></html>